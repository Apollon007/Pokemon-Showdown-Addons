diff --git a/app.js b/app.js
index 0cf2e13..88ef840 100644
--- a/app.js
+++ b/app.js
@@ -376,10 +376,12 @@ global.CommandParser = require('./command-parser.js');
 
 global.Simulator = require('./simulator.js');
 
 global.Tournaments = require('./tournaments/frontend.js');
 
+global.Clans = require('./clans.js');
+
 try {
 	global.Dnsbl = require('./dnsbl.js');
 } catch (e) {
 	global.Dnsbl = {query:function (){}};
 }
diff --git a/clans.js b/clans.js
new file mode 100644
index 0000000..466687b
--- /dev/null
+++ b/clans.js
@@ -0,0 +1,302 @@
+const clanDataFile = './config/clans.json';
+
+var fs = require('fs');
+var elo = require('elo-rank')();
+
+if (!fs.existsSync(clanDataFile))
+	fs.writeFileSync(clanDataFile, '{}');
+var clans = JSON.parse(fs.readFileSync(clanDataFile).toString());
+var pendingWars = {};
+
+exports.clans = clans;
+exports.pendingWars = pendingWars;
+
+function writeClanData() {
+	fs.writeFileSync(clanDataFile, JSON.stringify(clans));
+}
+
+exports.getClans = function () {
+	return Object.keys(clans).map(function (c) { return clans[c].name; });
+};
+
+exports.getClanName = function (clan) {
+	var clanId = toId(clan);
+	return clans[clanId] ? clans[clanId].name : "";
+};
+
+exports.getRating = function (clan) {
+	var clanId = toId(clan);
+	if (!clans[clanId])
+		return false;
+
+	return {
+		wins: clans[clanId].wins,
+		losses: clans[clanId].losses,
+		draws: clans[clanId].draws,
+		rating: clans[clanId].rating,
+		ratingName: exports.ratingToName(clans[clanId].rating)
+	};
+};
+
+exports.ratingToName = function (rating) {
+	if (rating > 1500)
+		return "Gold";
+	else if (rating > 1200)
+		return "Silver";
+	else
+		return "Bronze";
+};
+
+exports.createClan = function (name) {
+	var id = toId(name);
+	if (clans[id])
+		return false;
+
+	clans[id] = {
+		name: name,
+		members: {},
+		wins: 0,
+		losses: 0,
+		draws: 0,
+		rating: 1000
+	};
+	writeClanData();
+
+	return true;
+};
+
+exports.deleteClan = function (name) {
+	var id = toId(name);
+	if (!clans[id] || exports.findWarFromClan(id))
+		return false;
+
+	delete clans[id];
+	writeClanData();
+
+	return true;
+};
+
+exports.getMembers = function (clan) {
+	var clanId = toId(clan);
+	if (!clans[clanId])
+		return false;
+
+	return Object.keys(clans[clanId].members);
+};
+
+exports.getAvailableMembers = function (clan) {
+	var clanId = toId(clan);
+	if (!clans[clanId])
+		return false;
+
+	var results = [];
+	for (var m in clans[clanId].members) {
+		var user = Users.getExact(m);
+		if (user && user.connected && user.isClanWarAvailable > Date.now() - (5).minutes())
+			results.push(m);
+	}
+
+	return results;
+};
+
+exports.findClanFromMember = function (user) {
+	var userId = toId(user);
+	for (var c in clans)
+		if (clans[c].members[userId])
+			return clans[c].name;
+	return false;
+};
+
+exports.addMember = function (clan, user) {
+	var clanId = toId(clan);
+	var userId = toId(user);
+	if (!clans[clanId] || exports.findClanFromMember(user))
+		return false;
+
+	clans[clanId].members[userId] = 1;
+	writeClanData();
+
+	return true;
+};
+
+exports.removeMember = function (clan, user) {
+	var clanId = toId(clan);
+	var userId = toId(user);
+	if (!clans[clanId] || !clans[clanId].members[userId])
+		return false;
+
+	delete clans[clanId].members[userId];
+	writeClanData();
+
+	return true;
+};
+
+exports.getWars = function () {
+	return Object.keys(pendingWars).map(function (clan) { return [clan, pendingWars[clan.against]]; });
+};
+
+exports.getWarMatchups = function (clan) {
+	var warringClans = exports.findWarFromClan(clan);
+	if (!warringClans)
+		return false;
+
+	return JSON.parse(JSON.stringify(pendingWars[warringClans[0]].matchups));
+};
+
+exports.getWarRoom = function (clan) {
+	var warringClans = exports.findWarFromClan(clan);
+	if (!warringClans)
+		return false;
+
+	return pendingWars[warringClans[0]].room;
+}
+
+exports.findWarFromClan = function (clan) {
+	var clanId = toId(clan);
+
+	if (pendingWars[clanId])
+		return [clanId, pendingWars[clanId].against];
+	for (var w in pendingWars)
+		if (pendingWars[w].against === clanId)
+			return [w, clanId];
+
+	return false;
+};
+
+exports.startWar = function (clanA, clanB, room) {
+	var clanAId = toId(clanA);
+	var clanBId = toId(clanB);
+	if (!clans[clanAId] || !clans[clanBId] || exports.findWarFromClan(clanA) || exports.findWarFromClan(clanB))
+		return false;
+
+	var clanAMembers = exports.getAvailableMembers(clanA).randomize();
+	var clanBMembers = exports.getAvailableMembers(clanB).randomize();
+	var memberCount = Math.min(clanAMembers.length, clanBMembers.length);
+	if (memberCount < 4)
+		return false;
+
+	var matchups = {};
+	for (var m = 0; m < memberCount; ++m)
+		matchups[toId(clanAMembers[m])] = {from: clanAMembers[m], to: clanBMembers[m]};
+
+	pendingWars[clanAId] = {
+		against: clanBId,
+		matchups: matchups,
+		score: 0,
+		room: room
+	};
+
+	return JSON.parse(JSON.stringify(matchups));
+};
+
+exports.endWar = function (clan) {
+	var warringClans = exports.findWarFromClan(clan);
+	if (!warringClans)
+		return false;
+
+	delete pendingWars[warringClans[0]];
+	return true;
+};
+
+exports.setWarResult = function (clanA, clanB, result) {
+	var clanAId = toId(clanA);
+	var clanBId = toId(clanB);
+	if (!clans[clanAId] || !clans[clanBId] || result < 0 || result > 1)
+		return false;
+
+	var clanAExpectedResult = elo.getExpected(clans[clanAId].rating, clans[clanBId].rating);
+	var clanBExpectedResult = elo.getExpected(clans[clanBId].rating, clans[clanAId].rating);
+	clans[clanAId].rating = elo.updateRating(clanAExpectedResult, result, clans[clanAId].rating);
+	clans[clanBId].rating = elo.updateRating(clanBExpectedResult, 1 - result, clans[clanBId].rating);
+
+	if (clans[clanAId].rating < 1000)
+		clans[clanAId].rating = 1000;
+	if (clans[clanBId].rating < 1000)
+		clans[clanBId].rating = 1000;
+
+	if (result === 1) {
+		++clans[clanAId].wins;
+		++clans[clanBId].losses;
+	} else if (result === 0) {
+		++clans[clanAId].losses;
+		++clans[clanBId].wins;
+	} else {
+		++clans[clanAId].draws;
+		++clans[clanBId].draws;
+	}
+
+	writeClanData();
+
+	return [clans[clanAId].rating, clans[clanBId].rating];
+};
+
+exports.setWarMatchResult = function (userA, userB, result) {
+	var userAId = toId(userA);
+	var userBId = toId(userB);
+
+	if (typeof result !== 'number') {
+		result = toId(result);
+		if (result === userAId)
+			result = 1;
+		else if (result === userBId)
+			result = 0;
+		else
+			result = 0.5;
+	}
+
+	var clanId = exports.findClanFromMember(userA);
+	if (!clanId)
+		return false;
+	var warringClans = exports.findWarFromClan(clanId);
+	if (!warringClans)
+		return false;
+	clanId = warringClans[0];
+
+	var matchup = pendingWars[clanId].matchups[userAId];
+	if (!matchup || matchup.to !== userBId) {
+		matchup = pendingWars[clanId].matchups[userBId];
+		if (!matchup || matchup.to !== userAId)
+			return false;
+	}
+	if (matchup.isEnded)
+		return false;
+
+	matchup.isEnded = true;
+	if (result !== 0 && result !== 1)
+		return true;
+
+	var winnerUserId = result === 1 ? userAId : userBId;
+	if (matchup.to === winnerUserId)
+		--pendingWars[clanId].score;
+	else
+		++pendingWars[clanId].score;
+
+	return true;
+};
+
+exports.isWarEnded = function (clan) {
+	var warringClans = exports.findWarFromClan(clan);
+	if (!warringClans)
+		return true;
+	var clanId = warringClans[0];
+
+	for (var m in pendingWars[clanId].matchups)
+		if (!pendingWars[clanId].matchups[m].isEnded)
+			return false;
+
+	var result = 0.5;
+	if (pendingWars[clanId].score > 0)
+		result = 1;
+	else if (pendingWars[clanId].score < 0)
+		result = 0;
+
+	var oldRatings = [clans[warringClans[0]].rating, clans[warringClans[1]].rating];
+	var newRatings = exports.setWarResult(warringClans[0], warringClans[1], result);
+
+	delete pendingWars[clanId];
+	return {
+		result: result,
+		oldRatings: oldRatings,
+		newRatings: newRatings
+	};
+};
diff --git a/config/commands.js b/config/commands.js
index 88e0117..6cf126c 100644
--- a/config/commands.js
+++ b/config/commands.js
@@ -1261,10 +1261,154 @@ var commands = exports.commands = {
 			}
 		};
 	})(),
 
 	/*********************************************************
+	 * Clan commands
+	 *********************************************************/
+
+	clanshelp: function () {
+		if (!this.canBroadcast()) return false;
+		this.sendReplyBox(
+			"/clans [name] - Gets information about all clans, or about the specified clan<br />" +
+			"/clanwaravailable - Sets yourself as available for clan wars for 5 minutes<br />" +
+			"/createclan &lt;name> - Creates a clan<br />" +
+			"/deleteclan &lt;name> - Deletes a clan<br />" +
+			"/addclanmember &lt;clan>, &lt;user> - Adds a user to a clan<br />" +
+			"/removeclanmember &lt;clan>, &lt;user> - Removes a user from a clan<br />" +
+			"/startclanwar &lt;clan 1>, &lt;clan 2> - Starts a war between two clans<br />" +
+			"/endclanwar &lt;clan> - Ends a clan war forcibly<br />" +
+			"/getclanwarmatchups &lt;clan> - Shows the war battles that haven't yet been started<br />"
+		);
+	},
+
+	createclan: function (target) {
+		if (!this.can('clans')) return false;
+		if (target.length < 2)
+			this.sendReply("The clan's name is too short.");
+		else if (!Clans.createClan(target))
+			this.sendReply("Could not create the clan. Does it already exist?");
+		else
+			this.sendReply("Clan: " + target + " successfully created.");
+	},
+
+	deleteclan: function (target) {
+		if (!this.can('clans')) return false;
+		if (!Clans.deleteClan(target))
+			this.sendReply("Could not delete the clan. Does it exist or is it currently in a war?");
+		else
+			this.sendReply("Clan: " + target + " successfully deleted.");
+	},
+
+	clan: 'getclans',
+	clans: 'getclans',
+	getclan: 'getclans',
+	getclans: function (target) {
+		if (!this.canBroadcast()) return false;
+
+		var clan = Clans.getRating(target);
+		if (!clan) {
+			target = Clans.findClanFromMember(target);
+			if (target)
+				clan = Clans.getRating(target);
+		}
+		if (!clan) {
+			this.sendReplyBox(
+				"<strong>Clans:</strong><br />" +
+				Clans.getClans().map(function (clan) {
+					var result = Clans.getRating(clan);
+					result.name = clan;
+					return result;
+				}).sort(function (a, b) {
+					return b.rating - a.rating;
+				}).map(function (clan) {
+					return '<strong>' + Tools.escapeHTML(clan.name) + ':</strong> ' + clan.ratingName + " (" + clan.rating + ") " + clan.wins + "/" + clan.losses + "/" + clan.draws;
+				}).join('<br />')
+			);
+			return;
+		}
+
+		this.sendReplyBox(
+			'<strong>' + Tools.escapeHTML(Clans.getClanName(target)) + '</strong><br />' +
+			"<strong>Rating:</strong> " + clan.ratingName + " (" + clan.rating + ")<br />" +
+			"<strong>Wins/Losses/Draws:</strong> " + clan.wins + "/" + clan.losses + "/" + clan.draws + '<br />' +
+			"<strong>Members:</strong> " + Tools.escapeHTML(Clans.getMembers(target).sort().join(", "))
+		);
+	},
+
+	addclanmember: function (target) {
+		if (!this.can('clans')) return false;
+		var params = target.split(',');
+		if (params.length !== 2) return this.sendReply("Usage: /addclanmember clan, member");
+
+		var user = Users.getExact(params[1]);
+		if (!user || !user.connected) return this.sendReply("User: " + params[1] + " is not online.");
+
+		if (!Clans.addMember(params[0], params[1]))
+			this.sendReply("Could not add the user to the clan. Does the clan exist or is the user already in another clan?");
+		else {
+			this.sendReply("User: " + user.name + " successfully added to the clan.");
+			Rooms.rooms.lobby.add('|raw|<div class="clans-user-join">' + Tools.escapeHTML(user.name) + " has joined clan: " + Tools.escapeHTML(Clans.getClanName(params[0])) + '</div>');
+		}
+	},
+
+	removeclanmember: function (target) {
+		if (!this.can('clans')) return false;
+		var params = target.split(',');
+		if (params.length !== 2) return this.sendReply("Usage: /removeclanmember clan, member");
+
+		if (!Clans.removeMember(params[0], params[1]))
+			this.sendReply("Could not remove the user from the clan. Does the clan exist or has the user already been removed from it?");
+		else {
+			this.sendReply("User: " + params[1] + " successfully removed from the clan.");
+			Rooms.rooms.lobby.add('|raw|<div class="clans-user-join">' + Tools.escapeHTML(params[1]) + " has left clan: " + Tools.escapeHTML(Clans.getClanName(params[0])) + '</div>');
+		}
+	},
+
+	clanwaravailable: function (target, room, user) {
+		user.isClanWarAvailable = Date.now();
+		this.sendReply("You have been marked available for clan wars for 5 minutes.");
+	},
+
+	startclanwar: function (target, room) {
+		if (!this.can('clans')) return false;
+		var params = target.split(',');
+		if (params.length !== 2) return this.sendReply("Usage: /startclanwar clan 1, clan 2");
+
+		var matchups = Clans.startWar(params[0], params[1], room);
+		if (!matchups) return this.sendReply("Could not start the war. Do the two clans exist and have enough available members? Get the members to do /clanwaravailable");
+
+		room.add('|raw|' +
+			"<div class=\"clans-war-start\">A clan war between " + Tools.escapeHTML(Clans.getClanName(params[0])) + " and	" + Tools.escapeHTML(Clans.getClanName(params[1])) + " has started!</div>" +
+			Object.keys(matchups).map(function (m) { return "<strong>" + Tools.escapeHTML(matchups[m].from) + "</strong> vs <strong>" + Tools.escapeHTML(matchups[m].to); }).join('<br />')
+		);
+	},
+
+	endclanwar: function (target) {
+		if (!this.can('clans')) return false;
+		var war = Clans.findWarFromClan(target);
+		if (!war) return this.sendReply("The clan war does not exist. Has it already ended?");
+
+		var room = Clans.getWarRoom(target);
+		Clans.endWar(target);
+		room.add("|raw|<div class=\"clans-war-end\">The clan war between " + Tools.escapeHTML(war[0]) + " and " + Tools.escapeHTML(war[1]) + " has been forcibly ended.</div>");
+		this.sendReply("The clan war has been ended.");
+	},
+
+	getclanwarmatchups: function (target) {
+		if (!this.canBroadcast()) return false;
+		var war = Clans.findWarFromClan(target);
+		if (!war) return this.sendReply("The clan war does not exist.");
+
+		var matchups = Clans.getWarMatchups(target);
+		this.sendReplyBox(
+			"<strong>Clan war matchups between " + Tools.escapeHTML(war[0]) + " and " + Tools.escapeHTML(war[1]) + ':</strong><br />' +
+			Object.keys(matchups).map(function (m) { return mathcups[m].isEnded ? "" : '<strong>' + Tools.escapeHTML(matchups[m].from) + "</strong> vs <strong>" + Tools.escapeHTML(matchups[m].to); }).join('<br />')
+		);
+	},
+
+	/*********************************************************
 	 * Help commands
 	 *********************************************************/
 
 	commands: 'help',
 	h: 'help',
diff --git a/rooms.js b/rooms.js
index 090d383..bca8371 100644
--- a/rooms.js
+++ b/rooms.js
@@ -564,10 +564,36 @@ var BattleRoom = (function () {
 		} else {
 			this.log = this.log.concat(message);
 		}
 	};
 	BattleRoom.prototype.win = function (winner) {
+		if (Clans.setWarMatchResult(this.p1, this.p2, winner)) {
+			var result = "drawn";
+			if (toId(winner) === toId(this.p1))
+				result = "won";
+			else if (toId(winner) === toId(this.p2))
+				result = "lost";
+
+			var war = Clans.findWarFromClan(Clans.findClanFromMember(this.p1));
+			Clans.getWarRoom(war[0]).add('|raw|<div class="clans-war-battle-result">(' + Tools.escapeHTML(war[0]) + " vs " + Tools.escapeHTML(war[1]) + ") " + Tools.escapeHTML(this.p1) + " has " + result + " the clan war battle against " + Tools.escapeHTML(this.p2) + '</div>');
+
+			var room = Clans.getWarRoom(war[0]);
+			var warEnd = Clans.isWarEnded(war[0]);
+			if (warEnd) {
+				result = "drawn";
+				if (warEnd.result === 1)
+					result = "won";
+				else if (warEnd.result === 0)
+					result = "lost";
+				room.add('|raw|' +
+					'<div class="clans-war-end">' + Tools.escapeHTML(war[0]) + " has " + result + " the clan war against " + Tools.escapeHTML(war[1]) + '</div>' +
+					'<strong>' + Tools.escapeHTML(war[0]) + ':</strong> ' + warEnd.oldRatings[0] + " &rarr; " + warEnd.newRatings[0] + " (" + Clans.ratingToName(warEnd.newRatings[0]) + ")<br />" +
+					'<strong>' + Tools.escapeHTML(war[1]) + ':</strong> ' + warEnd.oldRatings[1] + " &rarr; " + warEnd.newRatings[1] + " (" + Clans.ratingToName(warEnd.newRatings[1]) + ")"
+				);
+			}
+		}
+
 		if (this.rated) {
 			var winnerid = toId(winner);
 			var rated = this.rated;
 			this.rated = false;
 			var p1score = 0.5;
